#!/usr/bin/env bash
set -euo pipefail

# This script generates AWS profiles for all accounts and roles associated with an AWS SSO profile.
# It also lets you switch between AWS accounts and roles using the 'awsctx' command with no arguments.
# This probably works best if you just remove your existing AWS config file and start fresh with 'awsctx -i'.

# Check for color support
if ! tput colors >/dev/null 2>&1; then
    echo "Warning: Your terminal doesn't support colors. Some features may not display correctly."
    # Define color variables as empty strings
    rd=gr=yl=bl=mg=cy=wh=gy=or=it=bd=nc=""
else
    # Colors
    rd=$(tput setaf 1)   # Red
    gr=$(tput setaf 2)   # Green
    yl=$(tput setaf 3)   # Yellow
    bl=$(tput setaf 4)   # Blue
    mg=$(tput setaf 5)   # Magenta
    cy=$(tput setaf 6)   # Cyan
    wh=$(tput setaf 7)   # White
    gy=$(tput setaf 8)   # Gray
    or=$(tput setaf 208) # Orange
    it=$(tput sitm)      # Italic
    bd=$(tput bold)      # Bold
    nc=$(tput sgr0)      # No Color / Reset
fi

# Message printing function
printMsg() {
    local level="$1"
    local message="$2"
    local icon="${3:-}"  # Optional emoji icon, default to empty string if not provided
    
    case "$level" in
        "header")
            echo "${bd}${mg}$message${nc}"
            ;;
        "success")
            echo "${gr}$message${icon:+ $icon}${nc}"
            ;;
        "warning")
            echo "${yl}$message${icon:+ $icon}${nc}"
            ;;
        "error")
            echo "${rd}$message${icon:+ $icon}${nc}"
            ;;
        "info")
            echo "${wh}$message${nc}"
            ;;
        "help")
            echo "${gy}$message${nc}"
            ;;
        "prompt")
            echo "${mg}$message${nc}"
            ;;
        "code")
            echo "${bl}$message${nc}"
            ;;
        "highlight")
            echo "${or}$message${nc}"
            ;;
        *)
            echo "$message"
            ;;
    esac
}

# Initialize variables
DEBUG=false
CONTEXT_READY="false"
GENERATE_CONFIG="false"
OUTPUT_FORMAT=""
BROWSER_OVERRIDE=""
CLI_PAGER=""

get_config_dir() {
  # First check if ~/.config exists
  if [[ -d "${HOME}/.config" ]]; then
    echo "${HOME}/.config/awsctx"
  else
    # Fall back to ~/.awsctxrc
    echo "${HOME}"
  fi
}

get_config_file() {
  local config_dir
  config_dir=$(get_config_dir)
  
  if [[ "$config_dir" == "${HOME}" ]]; then
    echo "${HOME}/.awsctxrc"
  else
    echo "${config_dir}/awsctxrc"
  fi
}

load_config() {
  local config_file
  config_file=$(get_config_file)
  local config_dir
  config_dir=$(dirname "$config_file")

  if [[ ! -f "$config_file" ]]; then
    printMsg "error" "AWS Context configuration file not found at: $config_file"
    printMsg "info" "Would you like to create a new configuration file?"
    read -rp "${mg}Create config file? ${bl}[${gr}Y${bl}/${rd}n${bl}]${nc}: " create_config_prompt
    create_config_prompt=${create_config_prompt:-Y}
    
    if [[ "$create_config_prompt" =~ ^[Yy]$ ]]; then
      create_config "$config_file"
    else
      printMsg "error" "Configuration file is required to run awsctx. Exiting..." "üò¢"
      exit 1
    fi
  fi

  # Check if config file is readable
  if [[ ! -r "$config_file" ]]; then
    printMsg "error" "Config file exists but is not readable: $config_file" "ÔøΩÔøΩ"
    exit 1
  fi

  # Source the config file
  if [[ -f "$config_file" ]]; then
    # shellcheck source=/dev/null
    source "$config_file"
  else
    printMsg "error" "Failed to load config file: $config_file" "üò¢"
    exit 1
  fi

  # Validate required variables
  if [[ -z "${SSO_START_URL:-}" ]] || [[ -z "${SSO_REGION:-}" ]] || \
     [[ -z "${SSO_REGISTRATION_SCOPES:-}" ]] || [[ -z "${CROSS_ACCOUNT_PROFILE:-}" ]] || \
     [[ -z "${OUTPUT_FORMAT:-}" ]]; then
    printMsg "error" "Config file is missing required variables" "üòï"
    printMsg "warning" "Please ensure all required variables are set in: $config_file"
    printMsg "info" "Would you like to update the configuration file?"
    read -rp "${mg}Update config file? ${bl}[${gr}Y${bl}/${rd}n${bl}]${nc}: " update_config_prompt
    update_config_prompt=${update_config_prompt:-Y}
    
    if [[ "$update_config_prompt" =~ ^[Yy]$ ]]; then
      create_config "$config_file"
    else
      printMsg "error" "Configuration file is required to run awsctx. Exiting..." "üò¢"
      exit 1
    fi
  fi

  # Basic format check for region (just to catch obvious typos)
  if [[ ! "$SSO_REGION" =~ ^[a-z]{2}-[a-z]+-[0-9]{1}$ ]]; then
    printMsg "error" "Invalid AWS region format in config file: $SSO_REGION" "‚ö†Ô∏è"
    printMsg "info" "Region should be in the format: us-east-1, eu-west-2, etc."
    exit 1
  fi
}

create_config() {
  local config_file="$1"
  local config_dir
  config_dir=$(dirname "$config_file")

  printMsg "warning" "Creating AWS Context configuration file..."
  printMsg "info" "This will help you set up your AWS SSO configuration."
  printMsg "help" "You can get these values from your AWS IAM administrator."
  echo

  # Create config directory if it doesn't exist
  if [[ "$config_dir" != "${HOME}" ]]; then
    mkdir -p "$config_dir"
  fi

  # Prompt for SSO Directory ID
  while true; do
    printMsg "code" "AWS SSO Directory ID"
    printMsg "info" "This is your AWS SSO directory ID"
    printMsg "code" "Format: d-xxxxxxxx"
    printMsg "highlight" "Example: d-a1b2c3d4e5"
    printMsg "help" "You can find this in your AWS SSO console under 'Directory ID'"
    if [[ -n "${SSO_START_URL:-}" ]]; then
      # Extract just the directory ID from the full URL if needed
      local default_id
      if [[ "$SSO_START_URL" =~ ^https:// ]]; then
        default_id=$(echo "$SSO_START_URL" | sed -E 's|https://([^.]+)\.awsapps\.com/start|\1|')
      else
        default_id="$SSO_START_URL"
      fi
      read -rp "${mg}Enter Directory ID [${bl}${default_id}${mg}]: ${bl}" input
      SSO_START_URL=${input:-$default_id}
    else
      read -rp "${mg}Enter Directory ID: ${bl}" SSO_START_URL
    fi
    echo

    if [[ "$SSO_START_URL" =~ ^[a-zA-Z0-9-]+$ ]]; then
      # Construct the full SSO start URL
      SSO_START_URL="https://${SSO_START_URL}.awsapps.com/start"
      break
    else
      printMsg "error" "Invalid format. Please enter only alphanumeric characters and hyphens"
    fi
  done

  # Prompt for SSO_REGION
  while true; do
    printMsg "code" "AWS Region"
    printMsg "info" "This is the AWS region where your SSO is configured"
    printMsg "highlight" "Example: us-east-1"
    if [[ -n "${SSO_REGION:-}" ]]; then
      read -rp "${mg}Enter AWS Region [${bl}${SSO_REGION}${mg}]: ${bl}" input
      SSO_REGION=${input:-$SSO_REGION}
    else
      read -rp "${mg}Enter AWS Region: ${bl}" SSO_REGION
    fi
    echo

    if [[ "$SSO_REGION" =~ ^[a-z]{2}-[a-z]+-[0-9]{1}$ ]]; then
      break
    else
      printMsg "error" "Invalid region format. Please enter a region in the format: us-east-1, eu-west-2, etc."
    fi
  done

  # Prompt for SSO_REGISTRATION_SCOPES
  printMsg "code" "SSO Registration Scopes"
  printMsg "info" "This is the SSO permission scope for your AWS account"
  printMsg "highlight" "Example: sso:account:access"
  if [[ -n "${SSO_REGISTRATION_SCOPES:-}" ]]; then
    read -rp "${mg}Enter SSO Registration Scopes [${bl}${SSO_REGISTRATION_SCOPES}${mg}]: ${bl}" input
    SSO_REGISTRATION_SCOPES=${input:-$SSO_REGISTRATION_SCOPES}
  else
    read -rp "${mg}Enter SSO Registration Scopes: ${bl}" SSO_REGISTRATION_SCOPES
  fi
  echo

  # Prompt for CROSS_ACCOUNT_PROFILE
  printMsg "code" "Cross Account Profile"
  printMsg "info" "This is the name of the AWS profile that will be used to assume roles in other accounts"
  printMsg "highlight" "Example: cross-account-access"
  if [[ -n "${CROSS_ACCOUNT_PROFILE:-}" ]]; then
    read -rp "${mg}Enter Cross Account Profile name [${bl}${CROSS_ACCOUNT_PROFILE}${mg}]: ${bl}" input
    CROSS_ACCOUNT_PROFILE=${input:-$CROSS_ACCOUNT_PROFILE}
  else
    read -rp "${mg}Enter Cross Account Profile name: ${bl}" CROSS_ACCOUNT_PROFILE
  fi
  echo

  # Prompt for OUTPUT_FORMAT
  printMsg "code" "AWS CLI Output Format"
  printMsg "info" "This is the default output format for AWS CLI commands"
  printMsg "highlight" "Example: json, text, table, yaml, yaml-stream"
  
  # Define options for output format selection
  local output_options=(
    "json"
    "text"
    "table"
    "yaml"
    "yaml-stream"
  )
  
  # Use fzf to get user's choice
  local selected_format
  selected_format=$(printf "%s\n" "${output_options[@]}" | fzf --height=10 --layout=reverse --header="Select output format")
  
  if [[ -n "$selected_format" ]]; then
    OUTPUT_FORMAT="$selected_format"
  else
    printMsg "error" "No output format selected. Using default: json" "‚ö†Ô∏è"
    OUTPUT_FORMAT="json"
  fi
  printMsg "success" "Output format selected: $OUTPUT_FORMAT" "‚úÖ"

  # Ask about CLI pager preference
  read -rp "${mg}Would you like to set a CLI pager for AWS output? ${bl}[${gr}Y${bl}/${rd}n${bl}]${nc}: " USE_PAGER
  USE_PAGER=${USE_PAGER:-Y}
  if [[ "$USE_PAGER" =~ ^[Yy]$ ]]; then
    printMsg "info" "Common pager options:"
    # Define options for pager selection
    local pager_options=(
      "bat -Ppl yaml (Syntax highlighted output - requires bat)"
      "less (Standard pager)"
      "more (Simple pager)"
      "custom (Enter your own pager command)"
    )
    
    # Use fzf to get user's choice
    local selected_pager
    selected_pager=$(printf "%s\n" "${pager_options[@]}" | fzf --height=10 --layout=reverse --header="Select pager")
    
    case "$selected_pager" in
      "bat -Ppl yaml (Syntax highlighted output - requires bat)")
        # Check if bat is installed
        if ! command -v bat &> /dev/null; then
          printMsg "error" "bat is not installed. Please install bat to use this option." "‚ö†Ô∏è"
          printMsg "info" "https://github.com/sharkdp/bat#installation"
          CLI_PAGER=""
        else
          CLI_PAGER="bat -Ppl yaml"
        fi
        ;;
      "less (Standard pager)")
        CLI_PAGER="less"
        ;;
      "more (Simple pager)")
        CLI_PAGER="more"
        ;;
      "custom (Enter your own pager command)")
        read -r -p "Enter your custom pager command: " CLI_PAGER
        ;;
      *)
        printMsg "warning" "Invalid selection. No pager will be set." "‚ö†Ô∏è"
        CLI_PAGER=""
        ;;
    esac
  fi

  # Write config file
  cat > "$config_file" << EOF
# AWS Context Manager Configuration
# This file contains your AWS SSO configuration
# You can modify these values at any time

SSO_START_URL="$SSO_START_URL"
SSO_REGION="$SSO_REGION"
SSO_REGISTRATION_SCOPES="$SSO_REGISTRATION_SCOPES"
CROSS_ACCOUNT_PROFILE="$CROSS_ACCOUNT_PROFILE"
OUTPUT_FORMAT="$OUTPUT_FORMAT"
CLI_PAGER="$CLI_PAGER"
EOF

  printMsg "success" "Configuration file created successfully at: $config_file" "‚úÖ"
  printMsg "info" "You can edit this file at any time to update your configuration."
}

check_command() {
  local cmd=$1
  local url=$2
  if ! command -v "$cmd" &>/dev/null; then
    printMsg "error" "The '$cmd' command could not be found" "ü§∑‚Äç‚ôÇÔ∏è"
    printMsg "info" "Please install '$cmd' from $url"
    exit 1
  fi
}

check_aws_cli_v2() {
  if ! command -v aws &>/dev/null; then
    printMsg "error" "The 'aws' command could not be found" "ü§∑‚Äç‚ôÇÔ∏è"
    printMsg "info" "Please install AWS CLI v2 from https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html"
    exit 1
  fi
  local version
  version=$(aws --version 2>&1)
  if [[ $version != aws-cli/2* ]]; then
    printMsg "error" "AWS CLI v2 is required" "üèöÔ∏è"
    printMsg "info" "Please install it from https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html"
    exit 1
  fi
}

# Check dependencies
check_command "jq" "https://github.com/jqlang/jq"
check_command "fzf" "https://github.com/junegunn/fzf"
check_aws_cli_v2

# Set up debug mode if enabled
if [[ "$DEBUG" == "true" ]]; then
    set -x
    PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
fi

# Load configuration
load_config

AWS_CONFIG_HOME="${HOME}/.aws"
AWS_CONFIG_FILE="${AWS_CONFIG_HOME}/config"
SSO_CACHE_DIR="${AWS_CONFIG_HOME}/sso/cache"
KUBE_HOME="${HOME}/.kube"
CURRENT_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date -u "+%Y-%m-%dT%H:%M:%SZ")

[[ ! -d "${AWS_CONFIG_HOME}" ]] && mkdir -p "${AWS_CONFIG_HOME}"
[[ ! -e "${AWS_CONFIG_FILE}" ]] && touch "${AWS_CONFIG_FILE}"

# Create temporary files with better error handling
create_temp_file() {
    local temp_file
    temp_file=$(mktemp "${AWS_CONFIG_HOME}/$1.XXXXXX" 2>/dev/null)
    if [[ -z "$temp_file" ]]; then
        printMsg "error" "Failed to create temporary file for $1" "üò¢"
        exit 1
    fi
    echo "$temp_file"
}

AWS_CONFIG_PROFILES=$(create_temp_file "AWS_CONFIG_PROFILES")
ACCOUNTS_LIST=$(create_temp_file "ACCOUNTS_LIST")
ACCOUNTS_ROLES=$(create_temp_file "ACCOUNTS_ROLES")
CTX_CONFIG=$(create_temp_file "CTX_CONFIG")
TMP_ROLES=$(create_temp_file "TMP_ROLES")
WRITE_TMP=$(create_temp_file "WRITE_TMP")
SPINTMP=$(create_temp_file "SPINTMP")
REGION_COUNTS=$(create_temp_file "aws_region_counts")
SESSION_BLOCK=$(cat <<-EOF
[sso-session awsctx]
sso_start_url = $SSO_START_URL
sso_region = $SSO_REGION
sso_registration_scopes = $SSO_REGISTRATION_SCOPES
EOF
)

cleanup_temp_files() {
  # Only attempt to remove files if their variables are set and the files exist
  [[ -n "$ACCOUNTS_LIST" && -f "$ACCOUNTS_LIST" ]] && rm -f "$ACCOUNTS_LIST"
  [[ -n "$ACCOUNTS_ROLES" && -f "$ACCOUNTS_ROLES" ]] && rm -f "$ACCOUNTS_ROLES"
  [[ -n "$CTX_CONFIG" && -f "$CTX_CONFIG" ]] && rm -f "$CTX_CONFIG"
  [[ -n "$TMP_ROLES" && -f "$TMP_ROLES" ]] && rm -f "$TMP_ROLES"
  [[ -n "$WRITE_TMP" && -f "$WRITE_TMP" ]] && rm -f "$WRITE_TMP"
  [[ -n "$AWS_CONFIG_PROFILES" && -f "$AWS_CONFIG_PROFILES" ]] && rm -f "$AWS_CONFIG_PROFILES"
  [[ -n "$SPINTMP" && -f "$SPINTMP" ]] && rm -f "$SPINTMP"
  [[ -n "$REGION_COUNTS" && -f "$REGION_COUNTS" ]] && rm -f "$REGION_COUNTS"
}

shutdown() {
  tput cnorm
  cleanup_temp_files
  # Kill any background processes
  jobs -p | xargs -r kill 2>/dev/null
}

trap shutdown INT EXIT TERM ERR

_cursorBack() {
  echo -en "\033[$1D"
}

_spinner() {
  local xtrace
  xtrace=$(set -o | grep xtrace | awk '{print $2}')
  set +x
  local LC_CTYPE=C
  local LC_ALL=en_US.utf-8
  tput civis
  local CL="\e[2K"
  local spin='‚¢ø‚£ø‚£ª‚£ø‚£Ω‚£ø‚£æ‚£ø‚£∑‚£ø‚£ø‚£æ‚£ø‚£∑‚£ø‚£Ø‚£ø‚£ü‚£ø‚°ø‚£ø‚¢ø‚°ø‚£ø'
  local pid
  pid=$(jobs -p)
  local charwidth=2
  local i=0
  while kill -0 "$pid" 2>/dev/null; do
    local i=$(((i + charwidth) % ${#spin}))
    printf "%s" "${gr}${spin:i:charwidth}${nc}"
    _cursorBack 2
    sleep .1
  done
  echo -ne "$CL"
  tput cnorm
  wait "$pid"
  if [[ "$xtrace" == "on" ]]; then
    set -x
  fi
}

use_spinner() {
  local cmd=$1
  shift
  "$cmd" "$@" >"$SPINTMP" &
  [[ $DEBUG == "true" ]] && set +x
  _spinner
  [[ $DEBUG == "true" ]] && set -x
  echo -ne "\r"
  cat "$SPINTMP"
}

run_aws_sso_login() {
  if [[ -n "$BROWSER_OVERRIDE" && "$BROWSER_OVERRIDE" != "none" ]]; then
    BROWSER="$BROWSER_OVERRIDE" aws sso login --sso-session awsctx
  elif [[ "$BROWSER_OVERRIDE" == "none" ]]; then
    aws sso login --sso-session awsctx --no-browser
  else
    aws sso login --sso-session awsctx
  fi
}

validate_output() {
  trap 'exit 2' SIGINT
  if [[ -z "$OUTPUT_FORMAT" ]]; then
    printMsg "error" "No output format provided with the ${it}-o${nc}${rd} flag ü™ß${nc}"
    
    # Define options for output format selection
    local output_options=(
      "json"
      "text"
      "table"
      "yaml"
      "yaml-stream"
    )
    
    # Use fzf to get user's choice
    local selected_format
    selected_format=$(printf "%s\n" "${output_options[@]}" | fzf --height=10 --layout=reverse --header="Select output format")
    
    if [[ -n "$selected_format" ]]; then
      OUTPUT_FORMAT="$selected_format"
    else
      printMsg "error" "No output format selected. Using default: json" "‚ö†Ô∏è"
      OUTPUT_FORMAT="json"
    fi
  fi
  printMsg "success" "Output format selected: $OUTPUT_FORMAT" "‚úÖ"

  # Ask about CLI pager preference only if not already set
  if [[ -z "${CLI_PAGER:-}" ]]; then
    read -rp "${mg}Would you like to set a CLI pager for AWS output? ${bl}[${gr}Y${bl}/${rd}n${bl}]${nc}: " USE_PAGER
    USE_PAGER=${USE_PAGER:-Y}
    if [[ "$USE_PAGER" =~ ^[Yy]$ ]]; then
      printMsg "info" "Common pager options:"
      # Define options for pager selection
      local pager_options=(
        "bat -Ppl yaml (Syntax highlighted output - requires bat)"
        "less (Standard pager)"
        "more (Simple pager)"
        "custom (Enter your own pager command)"
      )
      
      # Use fzf to get user's choice
      local selected_pager
      selected_pager=$(printf "%s\n" "${pager_options[@]}" | fzf --height=10 --layout=reverse --header="Select pager")
      
      case "$selected_pager" in
        "bat -Ppl yaml (Syntax highlighted output - requires bat)")
          # Check if bat is installed
          if ! command -v bat &> /dev/null; then
            printMsg "error" "bat is not installed. Please install bat to use this option." "‚ö†Ô∏è"
            printMsg "info" "https://github.com/sharkdp/bat#installation"
            CLI_PAGER=""
          else
            CLI_PAGER="bat -Ppl yaml"
          fi
          ;;
        "less (Standard pager)")
          CLI_PAGER="less"
          ;;
        "more (Simple pager)")
          CLI_PAGER="more"
          ;;
        "custom (Enter your own pager command)")
          read -r -p "Enter your custom pager command: " CLI_PAGER
          ;;
        *)
          printMsg "warning" "Invalid selection. No pager will be set." "‚ö†Ô∏è"
          CLI_PAGER=""
          ;;
      esac
    fi
  fi
}

setup_aws_config() {
  trap 'exit 2' SIGINT
  unset AWS_PROFILE
  if [[ -e "${AWS_CONFIG_FILE}" && -s "${AWS_CONFIG_FILE}" ]]; then
    printMsg "warning" "This will overwrite your existing AWS config file: ${AWS_CONFIG_FILE}" "‚ö†Ô∏è"
    read -rp "${mg}Would you like to backup your existing AWS config file? ${bl}[${gr}Y${bl}/${rd}n${bl}]${nc}: " BACKUP
    BACKUP=${BACKUP:-Y}
    if [[ "$BACKUP" =~ ^[Yy]$ ]]; then
      printMsg "info" "Backing up existing AWS config file: ${AWS_CONFIG_FILE}" "üíæ"
      mv "${AWS_CONFIG_FILE}" "${AWS_CONFIG_FILE}.$(date "+%d%b%Y_%H-%M-%S")"
      touch "${AWS_CONFIG_FILE}"
    fi
  fi
  echo "$SESSION_BLOCK" > "${AWS_CONFIG_FILE}"
  if run_aws_sso_login; then
    printMsg "success" "AWS SSO configuration initialized successfully" "‚úÖ"
    read -rp "${bl}Would you like to generate AWS profiles now? ${bl}[${gr}Y${bl}/${rd}n${bl}]${nc}: " generate_now
    generate_now=${generate_now:-Y}
    if [[ "$generate_now" =~ ^[Yy]$ ]]; then
      GENERATE_CONFIG="true"
      if [[ -z "$OUTPUT_FORMAT" ]]; then
        validate_output
      fi
      generate_config
      exit 0  # Exit after generating config to prevent double execution
    else
      printMsg "info" "You can run '${bl}${bd}awsctx -g${nc}' later to generate your AWS profiles"
    fi
  else
    printMsg "error" "Failed to initialize AWS CLI configuration" "üò≠"
    exit 1
  fi
}

count_resources() {
  local region=$1
  local count=0
  ec2_count=$(aws ec2 describe-instances --region "$region" --query "Reservations[*].Instances[*].[InstanceId]" --output text | wc -l)
  s3_count=0
  if [[ "$region" == "us-east-1" ]]; then
    s3_count=$(aws s3api list-buckets --query "Buckets[*].Name" --output text | wc -l)
  fi
  lambda_count=$(aws lambda list-functions --region "$region" --query "Functions[*].FunctionName" --output text | wc -l)
  rds_instance_count=$(aws rds describe-db-instances --region "$region" --query "DBInstances[*].DBInstanceIdentifier" --output text | wc -l)
  rds_cluster_count=$(aws rds describe-db-clusters --region "$region" --query "DBClusters[*].DBClusterIdentifier" --output text | wc -l)
  count=$((ec2_count + s3_count + lambda_count + rds_instance_count + rds_cluster_count))
  echo "$region=$count" >>"$REGION_COUNTS"
}

calculate_region_counts() {
  trap 'exit 2' SIGINT
  rm -f "$REGION_COUNTS"
  IFS=$'\t' read -r -a region_array <<<"$regions"
  for region in "${region_array[@]}"; do
    count_resources "$region" &
  done
  wait
  while IFS='=' read -r region count; do
    region_counts["$region"]=$count
  done <"$REGION_COUNTS"
  max_count=0
  primary_region=""
  for region in "${!region_counts[@]}"; do
    if ((region_counts[$region] > max_count)); then
      max_count=${region_counts[$region]}
      primary_region=$region
    fi
  done
}

generate_bar() {
  local count=$1
  local max_count=$2
  local length=70
  local bar_length=$((count * length / max_count))
  local bar=""
  local part_length=$((length / 2))
  for ((i = 0; i < bar_length; i++)); do
    if ((i < part_length)); then
      local ratio=$((i * 100 / part_length))
      local red=$((255 * ratio / 100))
      local green=255
      local blue=0
    else
      local ratio=$(((i - part_length) * 100 / part_length))
      local red=255
      local green=$((255 * (100 - ratio) / 100))
      local blue=0
    fi
    bar="${bar}\e[48;2;${red};${green};${blue}m \e[0m"
  done
  echo -e "$bar"
}

validate_token() {
  trap 'exit 2' SIGINT
  if [[ ! -s ${AWS_CONFIG_FILE} ]]; then
    printMsg "error" "AWS config file empty: ${AWS_CONFIG_FILE}" "ü´•"
    printMsg "info" "Proceeding to initialize your AWS CLI configuration..."
    setup_aws_config
    return
  fi
  if [[ ! -d "$SSO_CACHE_DIR" ]]; then
    printMsg "error" "SSO cache directory not found: $SSO_CACHE_DIR" "üò∞"
    printMsg "info" "Proceeding to initialize your AWS CLI configuration..."
    setup_aws_config
    return
  fi
  LATEST_SSO_CACHE="$(find "${SSO_CACHE_DIR}" -type f -print0 | xargs -0 ls -t | head -n1)"
  ACCESS_TOKEN_FILE="${LATEST_SSO_CACHE}"
  ACCESS_TOKEN=""  # Initialize ACCESS_TOKEN
  if [[ ! -f "$ACCESS_TOKEN_FILE" ]]; then
    printMsg "error" "SSO access token could not be found" "üò¶"
    printMsg "info" "Proceeding to initialize your AWS CLI configuration..."
    setup_aws_config
    return
  else
    ACCESS_TOKEN=$(jq -e -r '.accessToken' "$ACCESS_TOKEN_FILE" || echo "")
    if [[ -z "$ACCESS_TOKEN" ]]; then
      if [[ ! -f "${AWS_CONFIG_FILE}" ]]; then
        printMsg "error" "AWS config file not found: $AWS_CONFIG_FILE" "ü´•"
        printMsg "info" "Proceeding to initialize your AWS CLI configuration..."
        setup_aws_config
        return
      else
        printMsg "error" "SSO access token not found in cache directory: $SSO_CACHE_DIR" "üò∂‚Äçüå´Ô∏è"
        printMsg "info" "Please run '${bl}${bd}aws sso login --sso-session awsctx${nc}' to login to AWS SSO"
        read -rp "${mg}Attempt to login to AWS SSO? ${bl}[${gr}Y${bl}/${rd}n${bl}]${nc}: " attempt
        attempt=${attempt:-Y}
        if [[ "$attempt" =~ ^[Yy]$ ]]; then
          run_aws_sso_login
        else
          exit 1
        fi
      fi
    fi
    EXPIRES_AT=$(jq -e -r '.expiresAt' "$ACCESS_TOKEN_FILE")
    if [[ "$CURRENT_TIME" > "$EXPIRES_AT" ]]; then
      printMsg "error" "SSO access token has expired" "üë¥üèº"
      printMsg "info" "Please run '${bl}${bd}aws sso login --sso-session awsctx${nc}' to login to AWS SSO"
      read -rp "${mg}Attempt to login to AWS SSO? ${bl}[${gr}Y${bl}/${rd}n${bl}]${nc}: " attempt
      attempt=${attempt:-Y}
      if [[ "$attempt" =~ ^[Yy]$ ]]; then
        run_aws_sso_login
      else
        exit 1
      fi
    fi
  fi
}

build_accounts_list() {
  # Ensure we have a valid token before proceeding
  validate_token
  
  # Now we can safely use ACCESS_TOKEN as it will be set by validate_token
  aws \
    sso \
    list-accounts \
    --region us-east-1 \
    --access-token "$ACCESS_TOKEN" \
    --output json \
    --query "accountList[].{accountName: accountName, accountId: accountId}" | \
      jq 'map(
        .accountName |= (
          # Convert to lowercase, replace spaces and special chars with hyphens
          gsub("[^a-zA-Z0-9-]"; "-") |
          # Collapse multiple consecutive hyphens into a single hyphen
          gsub("-+"; "-") |
          # Remove leading/trailing hyphens
          gsub("^-|-$"; "")
        )
      ) | sort_by(.accountName|ascii_upcase)' \
    >"$ACCOUNTS_LIST"
}

accounts_load() {
  use_spinner build_accounts_list
}

build_roles_list() {
  trap 'exit 2' SIGINT
  
  # Ensure we have a valid token before proceeding
  validate_token
  
  echo "[]" >"$ACCOUNTS_ROLES"
  jq -e -c '.[]' "$ACCOUNTS_LIST" | while read -r account; do
    ACCOUNT_ID=$(echo "$account" | jq -e -r '.accountId')
    ROLES=$(
      aws \
        sso \
        list-account-roles \
        --region us-east-1 \
        --access-token "$ACCESS_TOKEN" \
        --account-id "$ACCOUNT_ID" \
        --output json \
        --query "sort_by(roleList, &roleName) | [].roleName"
    )
    if [[ -z "$ROLES" || "$ROLES" == "[]" ]]; then
      echo "${rd}No roles found for account ID $ACCOUNT_ID üôÖ${nc}"
      continue
    fi
    for role in $(echo "$ROLES" | jq -r '.[]'); do
      UPDATED_ACCOUNT=$(echo "$account" | jq -e --arg role "$role" '. + {sso_role_name: $role}')
      jq -e --argjson newAccount "$UPDATED_ACCOUNT" '. += [$newAccount]' "$ACCOUNTS_ROLES" >"$TMP_ROLES"
      mv "$TMP_ROLES" "$ACCOUNTS_ROLES"
    done
  done
}

roles_load() {
  use_spinner build_roles_list
}

write_config() {
  # Create a temporary file for the default profile section
  local default_section
  default_section=$(create_temp_file "default_section")

  # Extract the default profile section to a temporary file first
  awk -v common_profile="profile $CROSS_ACCOUNT_PROFILE" '
    $0 ~ common_profile {in_default = 1; next}
    /^\[/ && in_default {in_default = 0}
    in_default && NF {print}
  ' "${AWS_CONFIG_PROFILES}" > "$default_section"

  # Write all config sections to AWS_CONFIG_PROFILES in a single operation
  {
    # Write session block
    echo "$SESSION_BLOCK"
    
    # Write account profiles
    jq -r '
      # Group by accountName to detect duplicates
      group_by(.accountName) |
      .[] |
      # For each group, if there is more than one entry, append role name to accountName
      if (length > 1) then
        .[] | . + {
          displayName: "\(.accountName)-\(.sso_role_name)"
        }
      else
        .[] | . + {
          displayName: .accountName
        }
      end |
      # Output the profile configuration
      "[profile \(.displayName)]\n" +
      "sso_session = awsctx\n" +
      "sso_account_id = \(.accountId | gsub("\"";""))\n" +
      "sso_role_name = \(.sso_role_name | gsub("\"";""))\n" +
      "region = \(if (.accountName | test("^(?i)uk-?")) then "eu-west-1" else "us-east-1" end)\n" +
      "output = '"$OUTPUT_FORMAT"'\n" +
      if ("'"$CLI_PAGER"'" != "") then "cli_pager = '"$CLI_PAGER"'\n" else "" end
    ' "$ACCOUNTS_ROLES"
    
    # Write default profile section
    echo "[default]"
    cat "$default_section"
  } > "${AWS_CONFIG_PROFILES}"

  # Clean up temporary file
  rm -f "$default_section"

  # Copy temporary file to final config file
  cp "${AWS_CONFIG_PROFILES}" "${AWS_CONFIG_FILE}"

  echo "${gr}AWS profiles have been successfully generated, and written to: ${AWS_CONFIG_FILE} ‚úÖ${nc}"
  echo "${wh}You can now use '${bl}${bd}awsctx${nc}${wh}' to switch between AWS accounts and roles üèÅ${nc}"
}

generate_config() {
  validate_output
  echo -n "üìá Populating Accounts..."
  accounts_load
  echo "üìá Populating Accounts...${gr}‚úì${nc}"
  echo -n "üë• Gathering roles for accounts..."
  roles_load
  echo "üë• Gathering roles for accounts...${gr}‚úì${nc}"
  write_config
}

print_heatmap() {
  printf "\n${bl}%-14s${nc} ‚îÇ ${bl}%s${nc}\n" "Region" "Resources"
  printf "%-14s‚îº%s\n" "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
  for region in "${!region_counts[@]}"; do
    count=${region_counts["$region"]}
    bar=$(generate_bar "$count" "$max_count")
    printf "%-14s ‚îÇ %s\n" "$region" "$bar"
  done
  echo -e "\\n${cy}The primary region with the majority of resources is: ${mg}$primary_region${nc}\\n"
}

process_profile() {
  local profile_name="$1"
  for region in $(aws --profile "$profile_name" ec2 describe-regions --query "Regions[].RegionName" --output text); do
    clusters=$(aws --profile "$profile_name" eks list-clusters --region "$region" --query "clusters[]" --output text)
    if [[ -n "$clusters" ]]; then
      for cluster in $clusters; do
        echo "${yl}Updating kubeconfig for cluster: $cluster in region: $region with profile: $profile_name${nc}"
        aws --profile "$profile_name" eks update-kubeconfig --region "$region" --name "$cluster"
      done
    fi
  done
}

detect_eks_clusters() {
  [[ ! -d "${KUBE_HOME}" ]] && mkdir -p "${KUBE_HOME}"
  export -f process_profile
  awk -F '[][]' '/^\[profile / {print $2}' "$AWS_CONFIG_FILE" | sed 's/^profile //' | \
    xargs -I {} -P 10 bash -c 'process_profile "$@"' _ "{}"
}

usage() {
  cat <<EOF
${bd}${mg}AWS Context Manager${nc}

${cy}Description:${nc}
  ${wh}This script helps interact with multiple AWS account profiles by generating an AWS${nc}
  ${wh}config that includes profiles for all accounts and roles associated with an AWS SSO${nc}
  ${wh}profile.${nc}
  ${wh}Once the profiles are generated, you can use $(basename "$0") (with no options)${nc}
  ${wh}to select from a list of accounts, and easily search/switch between them.${nc}

${cy}Usage: ${mg}$(basename "$0") ${yl}[options]${nc}

${cy}Options:${nc}
  ${yl}-b ${bl}<browser>${nc}           Specify the browser to use for AWS SSO login.
                         Use 'none' to disable browser and use --no-browser option.
  ${yl}-g${nc}                     Generate AWS config profiles from AWS SSO
  ${yl}-i${nc}                     Initialize AWS SSO configuration and login
  ${yl}-k${nc}                     Detect EKS clusters and update kubeconfig
  ${yl}-o ${bl}<output_format>${nc}     Specify the output format for AWS CLI commands
                         Valid options: ${it}json${nc}, ${it}text${nc}, ${it}table${nc}, ${it}yaml${nc}, ${it}yaml-stream${nc}
  ${yl}-r${nc}                     Generate an AWS Region Heatmap for the current profile
  ${yl}-v${nc}                     Enable verbose mode
  ${yl}-h, --help${nc}             Display this help message and exit

${cy}Examples:${nc}
  ${it}${gr}$(basename "$0") -i${nc}
      Initialize AWS SSO configuration and login
  ${it}${gr}$(basename "$0") -g${nc}
      Generate AWS config profiles from AWS SSO
  ${it}${gr}$(basename "$0") -k${nc}
      Detect EKS clusters and update kubeconfig
  ${it}${gr}$(basename "$0") -o json${nc}
      Specify the output format as JSON for AWS CLI commands
  ${it}${gr}$(basename "$0") -b firefox${nc}
      Use Firefox as the browser for AWS SSO login
  ${it}${gr}$(basename "$0") -b none${nc}
      Use --no-browser option for AWS SSO login
  ${it}${gr}$(basename "$0") -v${nc}
      Enable verbose mode

EOF
}

while getopts "b:ghikvo:r" opt; do
  case $opt in
  b) BROWSER_OVERRIDE="$OPTARG" ;;
  g) 
    GENERATE_CONFIG="true"
    if [[ -z "$OUTPUT_FORMAT" ]]; then
      validate_output
    fi
    ;;
  h)
    usage
    exit 0
    ;;
  i) setup_aws_config ;;
  k)
    check_command "kubectl" "https://kubernetes.io/docs/tasks/tools/"
    echo -n "${bl}Detecting EKS clusters... (This can take a while)${nc}"
    use_spinner detect_eks_clusters
    echo "${bl}Detecting EKS clusters...${gr}‚úì${nc}"
    exit 0
    ;;
  o) OUTPUT_FORMAT="$OPTARG" ;;
  r)
    CURRENT_PROFILE=$(grep -b2 "$(aws configure get profile.default.sso_account_id)" ~/.aws/config | grep 'profile' | cut -d' ' -f2 | cut -d']' -f1)
    echo "${mg}Generating AWS Region Heatmap for $CURRENT_PROFILE...${nc}"
    regions=$(aws ec2 describe-regions --query "Regions[].RegionName" --output text)
    declare -A region_counts
    calculate_region_counts
    use_spinner print_heatmap
    exit 0
    ;;
  v)
    DEBUG=true
    set -x
    ;;
  \?)
    echo "${rd}Invalid option: -$OPTARG üëÆüèª‚Äç‚ôÇÔ∏è${nc}"
    usage
    exit 1
    ;;
  :)
    echo "${rd}Option -$OPTARG requires an argument üòë${nc}"
    usage
    exit 1
    ;;
  esac
done

validate_token

if [[ "$GENERATE_CONFIG" == "true" ]]; then
  generate_config
  exit 0
fi

CONTEXT_READY="true"

change_context() {
  trap 'exit 2' SIGINT
  PROFILE_DISPLAY=$(awk -F '[][]' '/^\[profile / {print $2}' "$AWS_CONFIG_FILE" | sed 's/^profile //' | while read -r profile; do
    ACCOUNT_ID=$(grep -A 3 "\[profile $profile\]" "$AWS_CONFIG_FILE" | grep 'sso_account_id' | awk -F' = ' '{print $2}')
    ROLE_NAME=$(grep -A 3 "\[profile $profile\]" "$AWS_CONFIG_FILE" | grep 'sso_role_name' | awk -F' = ' '{print $2}')
    printf "%s (%s) [%s]\n" "$profile" "$ACCOUNT_ID" "$ROLE_NAME"
  done)
  SELECTED_PROFILE=$(echo "$PROFILE_DISPLAY" | fzf --height=50% --header='Select an AWS account to switch to. Type to filter accounts by name, number, or role:')
  if [[ -z "$SELECTED_PROFILE" ]]; then
    exit 0
  fi
  PROFILE_NAME=$(echo "$SELECTED_PROFILE" | awk -F' ' '{print $1}')
  awk '
      BEGIN {skip=0}
      /^\[default\]/ {skip=1}
      /^\[/ && !/^\[default\]/ {skip=0}
      !skip {print}
  ' "$AWS_CONFIG_FILE" >"$CTX_CONFIG"
  echo "[default]" >>"$CTX_CONFIG"
  # Use exact match for profile instead of substring match
  awk -v profile="profile $PROFILE_NAME" '
      $0 ~ "^\\[" profile "\\]$" {in_default = 1; next}
      /^\[/ && in_default {in_default = 0}
      in_default && NF {print}
  ' "$AWS_CONFIG_FILE" | tail -n +1 >>"$CTX_CONFIG"
  mv "$CTX_CONFIG" "$AWS_CONFIG_FILE"
  echo "${gr}Switched default profile to: $PROFILE_NAME üîÄ${nc}"
}

if [[ "$CONTEXT_READY" == "true" ]]; then
  change_context
fi
