#!/usr/bin/env bash
set -euo pipefail

# This script generates AWS profiles for all accounts and roles associated with an AWS SSO profile.
# It also lets you switch between AWS accounts and roles using the 'awsctx' command with no arguments.
# This probably works best if you just remove your existing AWS config file and start fresh with 'awsctx -i'.

VERSION="0.1.0"
GITHUB_REPO="wallentx/awsctx"

# Check for color support
if ! tput colors >/dev/null 2>&1; then
  echo "Warning: Your terminal doesn't support colors. Some features may not display correctly."
  # Define color variables as empty strings
  rd=gr=yl=bl=mg=cy=wh=gy=or=it=bd=nc=""
else
  # Colors
  rd=$(tput setaf 1)   # Red
  gr=$(tput setaf 2)   # Green
  yl=$(tput setaf 3)   # Yellow
  bl=$(tput setaf 4)   # Blue
  mg=$(tput setaf 5)   # Magenta
  cy=$(tput setaf 6)   # Cyan
  wh=$(tput setaf 7)   # White
  gy=$(tput setaf 8)   # Gray
  or=$(tput setaf 208) # Orange
  it=$(tput sitm)      # Italic
  bd=$(tput bold)      # Bold
  nc=$(tput sgr0)      # No Color / Reset
fi

# Unified message handling function
msg() {
  local class="$1"
  local message="$2"
  local extra="${3:-}" # Used for default value, icon, or other extras
  local response

  case "$class" in
  "header") echo "${bd}${mg}$message${nc}" ;;
  "success") echo "${gr}$message${extra:+ $extra}${nc}" ;;
  "warning") echo "${yl}$message${extra:+ $extra}${nc}" ;;
  "error") echo "${rd}$message${extra:+ $extra}${nc}" ;;
  "info") echo "${wh}$message${nc}" ;;
  "help") echo "${gy}$message${nc}" ;;
  "example") echo "${gy}${it}$message${nc}" ;;
  "code") echo "${bl}$message${nc}" ;;
  "highlight") echo "${or}$message${nc}" ;;
  "section") echo "${cy}$message${nc}" ;;
  "status") echo "${gy}$message${extra:+ $extra}${nc}" ;;

  # Interactive prompts
  "question")
    local default="${extra:-}"
    local prompt

    # Format based on default value
    if [[ ${default,,} == "n" ]]; then
      prompt="${mg}$message ${bl}[${gr}y${bl}/${rd}N${bl}]${nc}"
    elif [[ ${default,,} == "y" ]]; then
      prompt="${mg}$message ${bl}[${gr}Y${bl}/${rd}n${bl}]${nc}"
    else
      prompt="${mg}$message ${bl}[${gr}y${bl}/${rd}n${bl}]${nc}"
    fi

    while true; do
      echo -n "$prompt: "
      read -r response

      # Handle empty response
      if [[ -z $response ]]; then
        [[ -n $default ]] && response="$default" && break
        continue
      fi

      # Handle valid responses
      if [[ ${response,,} =~ ^[yn]$ ]]; then
        break
      fi

      echo -e "${rd}Please answer y or n${nc}"
    done

    [[ ${response,,} =~ ^y ]]
    return $?
    ;;

  "input")
    printf "${mg}%s${nc}: " "$message" >&2
    read -r response
    echo "$response"
    ;;

  "input_default")
    printf "${mg}%s ${bl}[${wh}%s${bl}]${nc}: " "$message" "$extra" >&2
    read -r response
    echo "${response:-$extra}"
    ;;

  "select")
    local -a options=("${@:3}") # Get all args after class and message

    # Display the menu to stderr
    for i in "${!options[@]}"; do
      printf '%s%d%s %s%s\n' "${bl}" "$((i + 1))" "${gy})" "${wh}${options[$i]}" "${nc}" >&2
    done

    # Get selection
    printf '%s%s%s: ' "${mg}" "$message" "${nc}" >&2
    read -r selection

    # Validate and return selection
    if [[ $selection =~ ^[0-9]+$ ]] && [ "$selection" -ge 1 ] && [ "$selection" -le "${#options[@]}" ]; then
      echo "${options[$((selection - 1))]}"
      return 0
    else
      printf '%s%s%s\n' "${rd}" "Invalid selection." "${nc}" >&2
      msg "select" "$message" "${options[@]}"
    fi
    ;;

  *) echo "$message" ;;
  esac
}

# Aliases for common message types (optional, for convenience)
error() { msg "error" "$1" "${2:-}"; }
warn() { msg "warning" "$1" "${2:-}"; }
info() { msg "info" "$1"; }
success() { msg "success" "$1" "${2:-}"; }
ask() { msg "question" "$1" "${2:-}"; }
prompt() { msg "input" "$1"; }
prompt_default() { msg "input_default" "$1" "$2"; }
select_option() { msg "select" "$1" "${@:2}"; }
title() { msg "header" "$1"; }
option() { msg "code" "$1"; }
section() { msg "section" "$1"; }
example() { msg "example" "$1"; }

# Initialize variables
DEBUG=false
CONTEXT_READY="false"
GENERATE_CONFIG="false"
OUTPUT_FORMAT=""
BROWSER_OVERRIDE=""
CLI_PAGER=""

# Declare global associative array for region counts
declare -A region_counts

get_config_dir() {
  # First check if ~/.config exists
  if [[ -d "${HOME}/.config" ]]; then
    echo "${HOME}/.config/awsctx"
  else
    # Fall back to ~/.awsctxrc
    echo "${HOME}"
  fi
}

get_config_file() {
  local config_dir
  config_dir=$(get_config_dir)

  if [[ $config_dir == "${HOME}" ]]; then
    echo "${HOME}/.awsctxrc"
  else
    echo "${config_dir}/awsctxrc"
  fi
}

load_config() {
  local config_file
  config_file=$(get_config_file)
  local config_dir
  config_dir=$(dirname "$config_file")

  if [[ ! -f $config_file ]]; then
    error "AWS Context configuration file not found at: $config_file"
    info "Would you like to create a new configuration file?"
    if ask "Create config file?"; then
      create_config "$config_file"
    else
      error "Configuration file is required to run awsctx. Exiting..." "üò¢"
      exit 1
    fi
  fi

  # Check if config file is readable
  if [[ ! -r $config_file ]]; then
    error "Config file exists but is not readable: $config_file" "üò¢"
    exit 1
  fi

  # Source the config file
  if [[ -f $config_file ]]; then
    # shellcheck source=/dev/null
    source "$config_file"
  else
    error "Failed to load config file: $config_file" "üò¢"
    exit 1
  fi

  # Validate required variables
  if [[ -z ${SSO_START_URL:-} ]] || [[ -z ${SSO_REGION:-} ]] ||
    [[ -z ${SSO_REGISTRATION_SCOPES:-} ]] || [[ -z ${CROSS_ACCOUNT_PROFILE:-} ]] ||
    [[ -z ${OUTPUT_FORMAT:-} ]]; then
    error "Config file is missing required variables" "üòï"
    warn "Please ensure all required variables are set in: $config_file"
    info "Would you like to update the configuration file?"
    if ask "Update config file?"; then
      create_config "$config_file"
    else
      error "Configuration file is required to run awsctx. Exiting..." "üò¢"
      exit 1
    fi
  fi

  # Basic format check for region (just to catch obvious typos)
  if [[ ! $SSO_REGION =~ ^[a-z]{2}-[a-z]+-[0-9]{1}$ ]]; then
    error "Invalid AWS region format in config file: $SSO_REGION" "‚ö†Ô∏è"
    info "Region should be in the format: us-east-1, eu-west-2, etc."
    exit 1
  fi
}

create_config() {
  local config_file="$1"
  local config_dir
  config_dir=$(dirname "$config_file")

  info "Creating AWS Context configuration file..."
  info "This will help you set up your AWS SSO configuration."
  info "You can get these values from your AWS IAM administrator."
  echo

  # Create config directory if it doesn't exist
  if [[ $config_dir != "${HOME}" ]]; then
    mkdir -p "$config_dir"
  fi

  # Prompt for SSO Directory ID
  while true; do
    code "AWS SSO Directory ID"
    info "This is your AWS SSO directory ID"
    code "Format: d-xxxxxxxx"
    example "Example: d-a1b2c3d4e5"
    info "You can find this in your AWS SSO console under 'Directory ID'"
    if [[ -n ${SSO_START_URL:-} ]]; then
      # Extract just the directory ID from the full URL if needed
      local default_id
      if [[ $SSO_START_URL =~ ^https:// ]]; then
        default_id=$(echo "$SSO_START_URL" | sed -E 's|https://([^.]+)\.awsapps\.com/start|\1|')
      else
        default_id="$SSO_START_URL"
      fi
      input=$(prompt_default "Enter Directory ID" "$default_id")
      SSO_START_URL=${input}
    else
      SSO_START_URL=$(prompt "Enter Directory ID")
    fi
    echo

    if [[ $SSO_START_URL =~ ^[a-zA-Z0-9-]+$ ]]; then
      # Construct the full SSO start URL
      SSO_START_URL="https://${SSO_START_URL}.awsapps.com/start"
      break
    else
      error "Invalid format. Please enter only alphanumeric characters and hyphens"
    fi
  done

  # Prompt for SSO_REGION
  while true; do
    code "AWS Region"
    info "This is the AWS region where your SSO is configured"
    highlight "Example: us-east-1"
    if [[ -n ${SSO_REGION:-} ]]; then
      input=$(prompt_default "Enter AWS Region" "$SSO_REGION")
      SSO_REGION=${input}
    else
      SSO_REGION=$(prompt "Enter AWS Region")
    fi
    echo

    if [[ $SSO_REGION =~ ^[a-z]{2}-[a-z]+-[0-9]{1}$ ]]; then
      break
    else
      error "Invalid region format. Please enter a region in the format: us-east-1, eu-west-2, etc."
    fi
  done

  # Prompt for SSO_REGISTRATION_SCOPES
  code "SSO Registration Scopes"
  info "This is the SSO permission scope for your AWS account"
  highlight "Example: sso:account:access"
  if [[ -n ${SSO_REGISTRATION_SCOPES:-} ]]; then
    input=$(prompt_default "Enter SSO Registration Scopes" "$SSO_REGISTRATION_SCOPES")
    SSO_REGISTRATION_SCOPES=${input}
  else
    SSO_REGISTRATION_SCOPES=$(prompt "Enter SSO Registration Scopes")
  fi
  echo

  # Prompt for CROSS_ACCOUNT_PROFILE
  code "Cross Account Profile"
  info "This is the name of the AWS profile that will be used to assume roles in other accounts"
  highlight "Example: cross-account-access"
  if [[ -n ${CROSS_ACCOUNT_PROFILE:-} ]]; then
    input=$(prompt_default "Enter Cross Account Profile name" "$CROSS_ACCOUNT_PROFILE")
    CROSS_ACCOUNT_PROFILE=${input}
  else
    CROSS_ACCOUNT_PROFILE=$(prompt "Enter Cross Account Profile name")
  fi
  echo

  # Prompt for OUTPUT_FORMAT
  code "AWS CLI Output Format"
  info "This is the default output format for AWS CLI commands"
  highlight "Example: json, text, table, yaml, yaml-stream"

  # Define options for output format selection
  local output_options=(
    "json"
    "text"
    "table"
    "yaml"
    "yaml-stream"
  )

  # Use fzf to get user's choice
  local selected_format
  selected_format=$(select_option "Select output format" "${output_options[@]}")

  if [[ -n $selected_format ]]; then
    OUTPUT_FORMAT="$selected_format"
  else
    error "No output format selected. Using default: json" "‚ö†Ô∏è"
    OUTPUT_FORMAT="json"
  fi
  success "Output format selected: $OUTPUT_FORMAT" "‚úÖ"

  # Ask about CLI pager preference
  if ask "Would you like to set a CLI pager for AWS output?"; then
    info "Common pager options:"
    # Define options for pager selection
    local pager_options=(
      "bat -Ppl yaml (Syntax highlighted output - requires bat)"
      "less (Standard pager)"
      "more (Simple pager)"
      "custom (Enter your own pager command)"
    )

    # Use fzf to get user's choice
    local selected_pager
    selected_pager=$(select_option "Select pager" "${pager_options[@]}")

    case "$selected_pager" in
    "bat -Ppl yaml (Syntax highlighted output - requires bat)")
      # Check if bat is installed
      if ! command -v bat &>/dev/null; then
        error "bat is not installed. Please install bat to use this option." "‚ö†Ô∏è"
        info "https://github.com/sharkdp/bat#installation"
        CLI_PAGER=""
      else
        CLI_PAGER="bat -Ppl yaml"
      fi
      ;;
    "less (Standard pager)")
      CLI_PAGER="less"
      ;;
    "more (Simple pager)")
      CLI_PAGER="more"
      ;;
    "custom (Enter your own pager command)")
      CLI_PAGER=$(prompt "Enter your custom pager command")
      ;;
    *)
      warn "Invalid selection. No pager will be set." "‚ö†Ô∏è"
      CLI_PAGER=""
      ;;
    esac
  fi

  # Write config file
  cat >"$config_file" <<EOF
# AWS Context Manager Configuration
# This file contains your AWS SSO configuration
# You can modify these values at any time

SSO_START_URL="$SSO_START_URL"
SSO_REGION="$SSO_REGION"
SSO_REGISTRATION_SCOPES="$SSO_REGISTRATION_SCOPES"
CROSS_ACCOUNT_PROFILE="$CROSS_ACCOUNT_PROFILE"
OUTPUT_FORMAT="$OUTPUT_FORMAT"
CLI_PAGER="$CLI_PAGER"
EOF

  success "Configuration file created successfully at: $config_file" "‚úÖ"
  info "You can edit this file at any time to update your configuration."
}

check_command() {
  local cmd=$1
  local url=$2
  if ! command -v "$cmd" &>/dev/null; then
    error "The '$cmd' command could not be found" "ü§∑‚Äç‚ôÇÔ∏è"
    info "Please install '$cmd' from $url"
    exit 1
  fi
}

check_bash_version() {
  local major_version=${BASH_VERSION%%.*}
  if [[ $major_version -lt 5 ]]; then
    error "Bash version 5 or higher is required" "üèöÔ∏è"
    info "You are currently running Bash version $BASH_VERSION"
    info "Please upgrade your Bash installation"
    info "On macOS, you can use: brew install bash"
    info "On Linux, use your distribution's package manager"
    exit 1
  fi
}

check_aws_cli_v2() {
  if ! command -v aws &>/dev/null; then
    error "The 'aws' command could not be found" "ü§∑‚Äç‚ôÇÔ∏è"
    info "Please install AWS CLI v2 from https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html"
    exit 1
  fi
  local version
  version=$(aws --version 2>&1)
  if [[ $version != aws-cli/2* ]]; then
    error "AWS CLI v2 is required" "üèöÔ∏è"
    info "Please install it from https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html"
    exit 1
  fi
}

# Check dependencies
check_bash_version
check_command "jq" "https://github.com/jqlang/jq"
check_command "fzf" "https://github.com/junegunn/fzf"
check_aws_cli_v2

# Set up debug mode if enabled
if [[ $DEBUG == "true" ]]; then
  set -x
  PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
fi

# Load configuration
load_config

AWS_CONFIG_HOME="${HOME}/.aws"
AWS_CONFIG_FILE="${AWS_CONFIG_HOME}/config"
SSO_CACHE_DIR="${AWS_CONFIG_HOME}/sso/cache"
KUBE_HOME="${HOME}/.kube"
CURRENT_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date -u "+%Y-%m-%dT%H:%M:%SZ")

[[ ! -d ${AWS_CONFIG_HOME} ]] && mkdir -p "${AWS_CONFIG_HOME}"
[[ ! -e ${AWS_CONFIG_FILE} ]] && touch "${AWS_CONFIG_FILE}"

# Create temporary files with better error handling
create_temp_file() {
  local temp_file
  temp_file=$(mktemp "${AWS_CONFIG_HOME}/$1.XXXXXX" 2>/dev/null)
  if [[ -z $temp_file ]]; then
    error "Failed to create temporary file for $1" "üò¢"
    exit 1
  fi
  echo "$temp_file"
}

AWS_CONFIG_PROFILES=$(create_temp_file "AWS_CONFIG_PROFILES")
ACCOUNTS_LIST=$(create_temp_file "ACCOUNTS_LIST")
ACCOUNTS_ROLES=$(create_temp_file "ACCOUNTS_ROLES")
CTX_CONFIG=$(create_temp_file "CTX_CONFIG")
TMP_ROLES=$(create_temp_file "TMP_ROLES")
WRITE_TMP=$(create_temp_file "WRITE_TMP")
SPINTMP=$(create_temp_file "SPINTMP")
REGION_COUNTS=$(create_temp_file "aws_region_counts")
SESSION_BLOCK=$(
  cat <<-EOF
[sso-session awsctx]
sso_start_url = $SSO_START_URL
sso_region = $SSO_REGION
sso_registration_scopes = $SSO_REGISTRATION_SCOPES
sso_client_name = awsctx
sdk_ua_app_id = awsctx
role_session_name = ${USER}_awsctx

EOF
)

cleanup_temp_files() {
  [[ -n $ACCOUNTS_LIST && -f $ACCOUNTS_LIST ]] && rm -f "$ACCOUNTS_LIST"
  [[ -n $ACCOUNTS_ROLES && -f $ACCOUNTS_ROLES ]] && rm -f "$ACCOUNTS_ROLES"
  [[ -n $CTX_CONFIG && -f $CTX_CONFIG ]] && rm -f "$CTX_CONFIG"
  [[ -n $TMP_ROLES && -f $TMP_ROLES ]] && rm -f "$TMP_ROLES"
  [[ -n $WRITE_TMP && -f $WRITE_TMP ]] && rm -f "$WRITE_TMP"
  [[ -n $AWS_CONFIG_PROFILES && -f $AWS_CONFIG_PROFILES ]] && rm -f "$AWS_CONFIG_PROFILES"
  [[ -n $SPINTMP && -f $SPINTMP ]] && rm -f "$SPINTMP"
  [[ -n $REGION_COUNTS && -f $REGION_COUNTS ]] && rm -f "$REGION_COUNTS"
}

shutdown() {
  tput cnorm
  cleanup_temp_files
  # Kill any background processes
  jobs -p | xargs -r kill 2>/dev/null
}

trap shutdown INT EXIT TERM ERR

_cursorBack() {
  echo -en "\033[$1D"
}

_spinner() {
  local xtrace
  xtrace=$(set -o | grep xtrace | awk '{print $2}')
  set +x
  local LC_CTYPE=C
  local LC_ALL=en_US.utf-8
  tput civis
  local CL="\e[2K"
  local spin='‚¢ø‚£ø‚£ª‚£ø‚£Ω‚£ø‚£æ‚£ø‚£∑‚£ø‚£ø‚£æ‚£ø‚£∑‚£ø‚£Ø‚£ø‚£ü‚£ø‚°ø‚£ø‚¢ø‚°ø‚£ø'
  local pid
  pid=$(jobs -p)
  local charwidth=2
  local i=0
  while kill -0 "$pid" 2>/dev/null; do
    local i=$(((i + charwidth) % ${#spin}))
    printf "%s" "${gr}${spin:i:charwidth}${nc}"
    _cursorBack 2
    sleep .1
  done
  echo -ne "$CL"
  tput cnorm
  wait "$pid"
  if [[ $xtrace == "on" ]]; then
    set -x
  fi
}

use_spinner() {
  local cmd=$1
  shift
  "$cmd" "$@" >"$SPINTMP" &
  [[ $DEBUG == "true" ]] && set +x
  _spinner
  [[ $DEBUG == "true" ]] && set -x
  echo -ne "\r"
  cat "$SPINTMP"
}

run_aws_sso_login() {
  if [[ -n $BROWSER_OVERRIDE && $BROWSER_OVERRIDE != "none" ]]; then
    BROWSER="$BROWSER_OVERRIDE" aws sso login --sso-session awsctx
  elif [[ $BROWSER_OVERRIDE == "none" ]]; then
    aws sso login --sso-session awsctx --no-browser
  else
    aws sso login --sso-session awsctx
  fi
}

validate_output() {
  trap 'exit 2' SIGINT
  if [[ -z $OUTPUT_FORMAT ]]; then
    error "No output format provided with the ${it}-o${nc}${rd} flag ü™ß${nc}"

    # Define options for output format selection
    local output_options=(
      "json"
      "text"
      "table"
      "yaml"
      "yaml-stream"
    )

    # Use fzf to get user's choice
    local selected_format
    selected_format=$(select_option "Select output format" "${output_options[@]}")

    if [[ -n $selected_format ]]; then
      OUTPUT_FORMAT="$selected_format"
    else
      error "No output format selected. Using default: json" "‚ö†Ô∏è"
      OUTPUT_FORMAT="json"
    fi
  fi
  success "Output format selected: $OUTPUT_FORMAT" "‚úÖ"

  # Ask about CLI pager preference only if not already set
  if [[ -z ${CLI_PAGER:-} ]]; then
    if ask "Would you like to set a CLI pager for AWS output?" "y"; then
      info "Common pager options:"
      # Define options for pager selection
      local pager_options=(
        "bat -Ppl yaml (Syntax highlighted output - requires bat)"
        "less (Standard pager)"
        "more (Simple pager)"
        "custom (Enter your own pager command)"
      )

      # Use fzf to get user's choice
      local selected_pager
      selected_pager=$(select_option "Select pager" "${pager_options[@]}")

      case "$selected_pager" in
      "bat -Ppl yaml (Syntax highlighted output - requires bat)")
        # Check if bat is installed
        if ! command -v bat &>/dev/null; then
          error "bat is not installed. Please install bat to use this option." "‚ö†Ô∏è"
          info "https://github.com/sharkdp/bat#installation"
          CLI_PAGER=""
        else
          CLI_PAGER="bat -Ppl yaml"
        fi
        ;;
      "less (Standard pager)")
        CLI_PAGER="less"
        ;;
      "more (Simple pager)")
        CLI_PAGER="more"
        ;;
      "custom (Enter your own pager command)")
        CLI_PAGER=$(prompt "Enter your custom pager command")
        ;;
      *)
        warn "Invalid selection. No pager will be set." "‚ö†Ô∏è"
        CLI_PAGER=""
        ;;
      esac
    fi
  fi
}

setup_aws_config() {
  trap 'exit 2' SIGINT
  unset AWS_PROFILE
  if [[ -e ${AWS_CONFIG_FILE} && -s ${AWS_CONFIG_FILE} ]]; then
    warn "This will overwrite your existing AWS config file: ${AWS_CONFIG_FILE}" "‚ö†Ô∏è"
    if ask "Would you like to backup your existing AWS config file?" "y"; then
      success "Backing up existing AWS config file: ${AWS_CONFIG_FILE}" "üíæ"
      mv "${AWS_CONFIG_FILE}" "${AWS_CONFIG_FILE}.$(date "+%d%b%Y_%H-%M-%S")"
      touch "${AWS_CONFIG_FILE}"
    fi
  fi
  echo "$SESSION_BLOCK" >"${AWS_CONFIG_FILE}"
  if run_aws_sso_login; then
    success "AWS SSO configuration initialized successfully" "‚úÖ"
    if ask "Would you like to generate AWS profiles now?" "y"; then
      GENERATE_CONFIG="true"
      if [[ -z $OUTPUT_FORMAT ]]; then
        validate_output
      fi
      generate_config
      exit 0 # Exit after generating config to prevent double execution
    else
      info "You can run '${bl}${bd}awsctx -g${nc}' later to generate your AWS profiles"
    fi
  else
    error "Failed to initialize AWS CLI configuration" "üò≠"
    exit 1
  fi
}

count_resources() {
  local region=$1
  local count=0

  # Use set +e to prevent individual AWS command failures from stopping the script
  set +e

  # Capture counts, defaulting to 0 if commands fail
  local ec2_count=0
  local s3_count=0
  local lambda_count=0
  local rds_instance_count=0
  local rds_cluster_count=0

  ec2_count=$(aws ec2 describe-instances --region "$region" --query "Reservations[*].Instances[*].[InstanceId]" --output text 2>/dev/null | wc -l) || ec2_count=0
  if [[ $region == "us-east-1" ]]; then
    s3_count=$(aws s3api list-buckets --query "Buckets[*].Name" --output text 2>/dev/null | wc -l) || s3_count=0
  fi
  lambda_count=$(aws lambda list-functions --region "$region" --query "Functions[*].FunctionName" --output text 2>/dev/null | wc -l) || lambda_count=0
  rds_instance_count=$(aws rds describe-db-instances --region "$region" --query "DBInstances[*].DBInstanceIdentifier" --output text 2>/dev/null | wc -l) || rds_instance_count=0
  rds_cluster_count=$(aws rds describe-db-clusters --region "$region" --query "DBClusters[*].DBClusterIdentifier" --output text 2>/dev/null | wc -l) || rds_cluster_count=0

  # Re-enable error checking
  set -e

  count=$((ec2_count + s3_count + lambda_count + rds_instance_count + rds_cluster_count))
  printf "%s=%d\n" "$region" "$count" >>"$REGION_COUNTS"
  return 0
}

calculate_region_counts() {
  trap 'exit 2' SIGINT
  rm -f "$REGION_COUNTS"
  touch "$REGION_COUNTS"

  # Clear the global associative array
  region_counts=()

  # Read regions into array
  readarray -t region_array < <(echo "$regions" | tr '\t' '\n')

  # Store PIDs for background processes
  pids=()

  # Start all region counts in background
  for region in "${region_array[@]}"; do
    count_resources "$region" &
    pids+=($!)
  done

  # Wait for all background processes to complete and check their exit status
  failed=0
  for pid in "${pids[@]}"; do
    wait "$pid" || ((failed++))
  done

  # Read the results
  while IFS='=' read -r region count; do
    if [[ -n $region && -n $count ]]; then
      region_counts["$region"]=$count
    fi
  done <"$REGION_COUNTS"

  # Find the maximum count and primary region
  max_count=0
  primary_region=""
  for region in "${!region_counts[@]}"; do
    if ((region_counts[$region] > max_count)); then
      max_count=${region_counts[$region]}
      primary_region=$region
    fi
  done

  # Export scalar variables
  export max_count primary_region
  return 0
}

generate_bar() {
  local count=$1
  local max_count=$2
  local length=70
  local bar_length=$((count * length / max_count))
  local bar=""
  local part_length=$((length / 2))
  for ((i = 0; i < bar_length; i++)); do
    if ((i < part_length)); then
      local ratio=$((i * 100 / part_length))
      local red=$((255 * ratio / 100))
      local green=255
      local blue=0
    else
      local ratio=$(((i - part_length) * 100 / part_length))
      local red=255
      local green=$((255 * (100 - ratio) / 100))
      local blue=0
    fi
    bar="${bar}\e[48;2;${red};${green};${blue}m \e[0m"
  done
  echo -e "$bar"
}

validate_token() {
  trap 'exit 2' SIGINT
  if [[ ! -s ${AWS_CONFIG_FILE} ]]; then
    error "AWS config file empty: ${AWS_CONFIG_FILE}" "ü´•"
    info "Proceeding to initialize your AWS CLI configuration..."
    setup_aws_config
    return
  fi
  if [[ ! -d $SSO_CACHE_DIR ]]; then
    error "SSO cache directory not found: $SSO_CACHE_DIR" "üò∞"
    info "Proceeding to initialize your AWS CLI configuration..."
    setup_aws_config
    return
  fi
  LATEST_SSO_CACHE="$(find "${SSO_CACHE_DIR}" -type f -print0 | xargs -0 ls -t | head -n1)"
  ACCESS_TOKEN_FILE="${LATEST_SSO_CACHE}"
  ACCESS_TOKEN="" # Initialize ACCESS_TOKEN
  if [[ ! -f $ACCESS_TOKEN_FILE ]]; then
    error "SSO access token could not be found" "üò¶"
    info "Proceeding to initialize your AWS CLI configuration..."
    setup_aws_config
    return
  else
    ACCESS_TOKEN=$(jq -e -r '.accessToken' "$ACCESS_TOKEN_FILE" || echo "")
    if [[ -z $ACCESS_TOKEN ]]; then
      if [[ ! -f ${AWS_CONFIG_FILE} ]]; then
        error "AWS config file not found: $AWS_CONFIG_FILE" "ü´•"
        info "Proceeding to initialize your AWS CLI configuration..."
        setup_aws_config
        return
      else
        error "SSO access token not found in cache directory: $SSO_CACHE_DIR" "üò∂‚Äçüå´Ô∏è"
        info "Please run '${bl}${bd}aws sso login --sso-session awsctx${nc}' to login to AWS SSO"
        if ask "Attempt to login to AWS SSO?" "y"; then
          run_aws_sso_login
        else
          exit 1
        fi
      fi
    fi
    EXPIRES_AT=$(jq -e -r '.expiresAt' "$ACCESS_TOKEN_FILE")
    if [[ $CURRENT_TIME > $EXPIRES_AT ]]; then
      error "SSO access token has expired" "üë¥üèº"
      info "Please run '${bl}${bd}aws sso login --sso-session awsctx${nc}' to login to AWS SSO"
      if ask "Attempt to login to AWS SSO?" "y"; then
        run_aws_sso_login
      else
        exit 1
      fi
    fi
  fi
}

build_accounts_list() {
  # Ensure we have a valid token before proceeding
  validate_token

  # Now we can safely use ACCESS_TOKEN as it will be set by validate_token
  aws \
    sso \
    list-accounts \
    --region us-east-1 \
    --access-token "$ACCESS_TOKEN" \
    --output json \
    --query "accountList[].{accountName: accountName, accountId: accountId}" |
    jq 'map(
        .accountName |= (
          # Convert to lowercase, replace spaces and special chars with hyphens
          gsub("[^a-zA-Z0-9-]"; "-") |
          # Collapse multiple consecutive hyphens into a single hyphen
          gsub("-+"; "-") |
          # Remove leading/trailing hyphens
          gsub("^-|-$"; "")
        )
      ) | sort_by(.accountName|ascii_upcase)' \
      >"$ACCOUNTS_LIST"
}

accounts_load() {
  use_spinner build_accounts_list
}

build_roles_list() {
  trap 'exit 2' SIGINT

  # Ensure we have a valid token before proceeding
  validate_token

  echo "[]" >"$ACCOUNTS_ROLES"
  jq -e -c '.[]' "$ACCOUNTS_LIST" | while read -r account; do
    ACCOUNT_ID=$(echo "$account" | jq -e -r '.accountId')
    ROLES=$(
      aws \
        sso \
        list-account-roles \
        --region us-east-1 \
        --access-token "$ACCESS_TOKEN" \
        --account-id "$ACCOUNT_ID" \
        --output json \
        --query "sort_by(roleList, &roleName) | [].roleName"
    )
    if [[ -z $ROLES || $ROLES == "[]" ]]; then
      warn "No roles found for account ID $ACCOUNT_ID üôÖ"
      continue
    fi
    for role in $(echo "$ROLES" | jq -r '.[]'); do
      UPDATED_ACCOUNT=$(echo "$account" | jq -e --arg role "$role" '. + {sso_role_name: $role}')
      jq -e --argjson newAccount "$UPDATED_ACCOUNT" '. += [$newAccount]' "$ACCOUNTS_ROLES" >"$TMP_ROLES"
      mv "$TMP_ROLES" "$ACCOUNTS_ROLES"
    done
  done
}

roles_load() {
  use_spinner build_roles_list
}

write_config() {
  # Create a temporary file for the default profile section
  local default_section
  default_section=$(create_temp_file "default_section")

  # Extract the default profile section to a temporary file first
  awk -v common_profile="profile $CROSS_ACCOUNT_PROFILE" '
    $0 ~ common_profile {in_default = 1; next}
    /^\[/ && in_default {in_default = 0}
    in_default && NF {print}
  ' "${AWS_CONFIG_PROFILES}" >"$default_section"

  # Write all config sections to AWS_CONFIG_PROFILES in a single operation
  {
    # Write session block
    echo "$SESSION_BLOCK"

    # Write account profiles
    jq -r '
      group_by(.accountName) |
      .[] |
        .[] | . + {
          displayName: "\(.sso_role_name)@\(.accountName)"
        } |
      "[profile \(.displayName)]\n" +
      "sso_session = awsctx\n" +
      "sso_account_id = \(.accountId | gsub("\"";""))\n" +
      "sso_role_name = \(.sso_role_name | gsub("\"";""))\n" +
      "region = \(if (.accountName | test("^(?i)uk-?")) then "eu-west-1" else "us-east-1" end)\n" +
      "output = '"$OUTPUT_FORMAT"'\n" +
      if ("'"$CLI_PAGER"'" != "") then "cli_pager = '"$CLI_PAGER"'\n" else "" end
    ' "$ACCOUNTS_ROLES"

    # Write default profile section
    echo "[default]"
    cat "$default_section"
  } >"${AWS_CONFIG_PROFILES}"

  # Clean up temporary file
  rm -f "$default_section"

  # Copy temporary file to final config file
  cp "${AWS_CONFIG_PROFILES}" "${AWS_CONFIG_FILE}"

  success "AWS profiles have been successfully generated, and written to: ${AWS_CONFIG_FILE}" "‚úÖ"
  info "You can now use '${bl}${bd}awsctx${nc}' to switch between AWS accounts and roles üèÅ"
}

generate_config() {
  validate_output
  echo -n "üìá Populating Accounts..."
  accounts_load
  echo "üìá Populating Accounts...${gr}‚úì${nc}"
  echo -n "üë• Gathering roles for accounts..."
  roles_load
  echo "üë• Gathering roles for accounts...${gr}‚úì${nc}"
  write_config
}

print_heatmap() {
  printf '\n%s%-14s%s ‚îÇ %s%s%s\n' "${bl}" "Region" "${nc}" "${bl}" "Resources" "${nc}"
  printf '%-14s‚îº%s\n' "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"

  # Sort regions alphabetically using mapfile
  mapfile -t sorted_regions < <(printf '%s\n' "${!region_counts[@]}" | sort)

  for region in "${sorted_regions[@]}"; do
    local count=${region_counts["$region"]}
    local bar=""

    if ((count > 0)); then
      bar=$(generate_bar "$count" "$max_count")
    fi

    printf '%-14s ‚îÇ %s\n' "$region" "$bar"
  done

  if [[ -n $primary_region ]]; then
    printf '\n%s%s%s%s%s (%d resources)\n\n' \
      "${cy}" "The primary region with the majority of resources is: " \
      "${mg}" "$primary_region" "${nc}" \
      "${region_counts[$primary_region]}"
  else
    printf '\n%s%s%s\n\n' "${cy}" "No resources found in any region." "${nc}"
  fi
  return 0
}

process_profile() {
  local profile_name="$1"
  local temp_config="$2"

  # Get list of all AWS regions and properly format them
  local regions
  regions=$(aws --profile "$profile_name" ec2 describe-regions --query "Regions[].RegionName" --output text 2>/dev/null | tr '\t' '\n' | sort) || {
    echo "Failed to get regions for profile: $profile_name"
    return 1
  }

  # Process each region
  while IFS= read -r region; do
    # Skip regions that are known to not have EKS (optional optimization)
    case "$region" in
      "ap-northeast-3") continue ;; # Osaka - Limited availability
      "ap-southeast-4") continue ;; # Melbourne - Limited availability
      "eu-south-2") continue ;;     # Spain - Limited availability
      "eu-central-2") continue ;;   # Zurich - Limited availability
      "il-central-1") continue ;;   # Israel - Limited availability
    esac

    # Try to list clusters in this region
    local clusters
    clusters=$(aws --profile "$profile_name" eks list-clusters --region "$region" --query "clusters[]" --output text 2>/dev/null) || continue

    if [[ -n $clusters ]]; then
      while IFS= read -r cluster; do
        echo "Found cluster: $cluster in region: $region with profile: $profile_name"
        # Use just the cluster name instead of ARN, and suppress stdout
        KUBECONFIG="$temp_config" aws --profile "$profile_name" eks update-kubeconfig \
          --region "$region" \
          --name "$cluster" \
          --alias "$cluster" \
          >/dev/null || echo "Failed to update kubeconfig for cluster: $cluster in region: $region"
      done < <(echo "$clusters" | tr '\t' '\n')
    fi
  done < <(echo "$regions")
}

detect_eks_clusters() {
  local temp_dir
  
  # Create temp directory for configs
  temp_dir=$(mktemp -d "${KUBE_HOME}/configs.XXXXXX") || {
    error "Failed to create temporary directory" "‚ùå"
    return 1
  }

  # Ensure cleanup happens on exit
  trap 'rm -rf "$temp_dir"' EXIT

  [[ ! -d ${KUBE_HOME} ]] && mkdir -p "${KUBE_HOME}"
  [[ ! -f "${KUBE_HOME}/config" ]] && touch "${KUBE_HOME}/config"

  # Get all available accounts (everything after @ in profile names)
  local all_accounts
  all_accounts=$(awk -F '[][]' '/^\[profile / {print $2}' "$AWS_CONFIG_FILE" | 
    sed 's/^profile //' | 
    awk -F'@' '{print $2}' | 
    sort -u)

  # Create colored display for fzf
  local account_display=""
  while IFS= read -r account; do
    account_display+="${wh}${account}${nc}\n"
  done <<<"$all_accounts"

  # Remove trailing newline
  account_display=${account_display%\\n}

  # Let user select account(s) via fzf
  local selected_accounts
  selected_accounts=$(echo -e "$account_display" | fzf --ansi --multi --height=50% \
    --header="Select account(s) to check for EKS clusters (TAB to multi-select, ENTER to confirm):" \
    | sed -E "s/\x1B\[[0-9;]*[mK]//g") # Remove color codes

  # If no selection was made, exit
  if [[ -z $selected_accounts ]]; then
    echo "No accounts selected. Exiting..."
    return 0
  fi

  # Process each selected account
  local selected_profiles=""
  while IFS= read -r account; do
    # Get all roles for this account
    local account_roles
    account_roles=$(awk -F '[][]' '/^\[profile / {print $2}' "$AWS_CONFIG_FILE" | 
      sed 's/^profile //' | 
      grep "@${account}$" | 
      awk -F'@' '{print $1}' | 
      sort -u)

    # Count number of roles
    local role_count
    role_count=$(echo "$account_roles" | wc -l)

    if [[ $role_count -eq 1 ]]; then
      # If only one role, use it automatically
      local role
      role=$(echo "$account_roles" | head -n1)
      selected_profiles+="${role}@${account}"$'\n'
      echo "Using role ${bl}${role}${nc} for account ${wh}${account}${nc}"
    else
      # Create colored display for role selection
      local role_display=""
      while IFS= read -r role; do
        role_display+="${bl}${role}${nc}\n"
      done <<<"$account_roles"

      # Remove trailing newline
      role_display=${role_display%\\n}

      echo "Selecting roles for account: ${wh}${account}${nc}"
      # Let user select multiple roles
      local selected_roles
      selected_roles=$(echo -e "$role_display" | fzf --ansi --multi --height=50% \
        --header="Select role(s) to use for ${account} (TAB to multi-select, ENTER to confirm):" \
        | sed -E "s/\x1B\[[0-9;]*[mK]//g")

      if [[ -n $selected_roles ]]; then
        while IFS= read -r selected_role; do
          selected_profiles+="${selected_role}@${account}"$'\n'
          echo "Selected role ${bl}${selected_role}${nc} for account ${wh}${account}${nc}"
        done <<<"$selected_roles"
      fi
    fi
  done <<<"$selected_accounts"

  # Remove trailing newline
  selected_profiles=${selected_profiles%$'\n'}

  if [[ -z $selected_profiles ]]; then
    echo "No profiles selected. Exiting..."
    return 0
  fi

  echo
  echo "Starting EKS cluster detection (processing 10 profiles at a time)..."
  echo

  # First create all temp files
  declare -A profile_to_file=()  # Map to store profile to filename mapping
  while IFS= read -r profile; do
    # Create a safe filename by replacing special characters
    safe_filename=$(echo "$profile" | tr -c '[:alnum:]' '_')
    temp_file="${temp_dir}/${safe_filename}.yaml"
    touch "$temp_file" || {
      error "Failed to create temporary file for profile: $profile" "‚ùå"
      return 1
    }
    profile_to_file["$profile"]="$temp_file"
  done <<<"$selected_profiles"

  # Now process in batches of 10
  local batch_size=10
  readarray -t profiles <<<"$selected_profiles"
  local num_profiles=${#profiles[@]}
  local batch_start=0

  while ((batch_start < num_profiles)); do
    local pids=()
    local batch_end=$((batch_start + batch_size))
    ((batch_end > num_profiles)) && batch_end=$num_profiles

    # Process this batch
    for ((i = batch_start; i < batch_end; i++)); do
      local profile="${profiles[$i]}"
      local temp_file="${profile_to_file[$profile]}"
      echo "Processing profile: ${bl}${profile}${nc}"
      process_profile "$profile" "$temp_file" &
      pids+=($!)
    done

    # Wait for all processes in this batch
    for pid in "${pids[@]}"; do
      wait "$pid" 2>/dev/null || true
    done

    batch_start=$batch_end
  done

  echo
  echo "EKS cluster detection complete. Merging kubeconfig files..."

  # Merge all configs
  local kubeconfigs="${KUBE_HOME}/config"
  for config in "${temp_dir}"/*.yaml; do
    if [[ -s $config ]]; then
      kubeconfigs+=":${config}"
    fi
  done

  if [[ $kubeconfigs != "${KUBE_HOME}/config" ]]; then
    KUBECONFIG="$kubeconfigs" kubectl config view --flatten >"${KUBE_HOME}/config.merged" || {
      error "Failed to merge kubeconfig files" "‚ùå"
      return 1
    }
    mv "${KUBE_HOME}/config.merged" "${KUBE_HOME}/config" || {
      error "Failed to update kubeconfig file" "‚ùå"
      return 1
    }
    echo "Kubeconfig files merged successfully."
  else
    echo "No EKS clusters found in selected accounts."
  fi

  # Cleanup handled by trap
  return 0
}

check_for_updates() {
  local latest_version
  msg "info" "Checking for updates..."

  # Get the latest release version from GitHub API
  latest_version=$(curl -s "https://api.github.com/repos/${GITHUB_REPO}/releases/latest" |
    jq -r '.tag_name // empty')

  if [[ -z $latest_version ]]; then
    msg "warn" "No releases found in ${GITHUB_REPO}"
    return 0
  fi

  # Remove 'v' prefix if present for comparison
  latest_version=${latest_version#v}
  current_version=${VERSION#v}

  # Compare versions (simple string comparison for now)
  if [[ $latest_version != "$current_version" ]]; then
    msg "warn" "New version available: ${latest_version} (current: ${current_version})"
    msg "info" "Visit https://github.com/${GITHUB_REPO}/releases/latest to download"
  else
    msg "success" "You are running the latest version (${current_version})"
  fi
}

usage() {
  title "AWS Context Manager"
  echo

  section "Description:"
  info "This script helps interact with multiple AWS account profiles by generating an AWS"
  info "config that includes profiles for all accounts and roles associated with an AWS SSO"
  info "profile."
  info "Once the profiles are generated, you can use $(basename "$0") (with no options)"
  info "to select from a list of accounts, and easily search/switch between them."
  echo

  section "Usage: $(basename "$0") [options]"
  echo

  section "Options:"
  option "-b <browser>           Specify the browser to use for AWS SSO login."
  option "                       Use 'none' to disable browser and use --no-browser option."
  option "-c                     Check for updates"
  option "-g                     Generate AWS config profiles from AWS SSO"
  option "-i                     Initialize AWS SSO configuration and login"
  option "-k                     Detect EKS clusters and update kubeconfig"
  option "-m                     Generate an AWS Region Heatmap for the current profile"
  option "-o <output_format>     Specify the output format for AWS CLI commands"
  option "                       Valid options: json, text, table, yaml, yaml-stream"
  option "-r                     Change region for the current context"
  option "-v                     Enable verbose mode"
  option "-h, --help            Display this help message and exit"
  echo

  section "Examples:"
  example "$(basename "$0") -i"
  info "    Initialize AWS SSO configuration and login"
  example "$(basename "$0") -g"
  info "    Generate AWS config profiles from AWS SSO"
  example "$(basename "$0") -k"
  info "    Detect EKS clusters and update kubeconfig"
  example "$(basename "$0") -m"
  info "    Generate an AWS Region Heatmap for the current profile"
  example "$(basename "$0") -o json"
  info "    Specify the output format as JSON for AWS CLI commands"
  example "$(basename "$0") -b firefox"
  info "    Use Firefox as the browser for AWS SSO login"
  example "$(basename "$0") -b none"
  info "    Use --no-browser option for AWS SSO login"
  example "$(basename "$0") -c"
  info "    Check for available updates"
  example "$(basename "$0") -v"
  info "    Enable verbose mode"
  echo

  section "Version: ${VERSION}"
}

change_region() {
  trap 'exit 2' SIGINT

  # Get the list of available regions for the current profile context
  echo -n "${bl}Fetching available regions...${nc}"
  REGIONS=$(aws ec2 describe-regions --query "Regions[].RegionName" --output json | jq -r '.[]' | sort)
  echo "${gr}‚úì${nc}"

  if [[ -z $REGIONS ]]; then
    error "Failed to fetch regions. Please ensure you have permissions to list regions." "‚ùå"
    exit 1
  fi

  # Create colored region display for fzf
  REGION_DISPLAY=""
  while read -r region; do
    case "${region%%-*}" in # Match on prefix only
    us)
      REGION_DISPLAY+="${bl}${region}${nc}\n"
      ;;
    af)
      REGION_DISPLAY+="${gr}${region}${nc}\n"
      ;;
    ap)
      REGION_DISPLAY+="${rd}${region}${nc}\n"
      ;;
    ca)
      REGION_DISPLAY+="${wh}${region}${nc}\n"
      ;;
    eu)
      REGION_DISPLAY+="${yl}${region}${nc}\n"
      ;;
    il)
      REGION_DISPLAY+="${cy}${region}${nc}\n"
      ;;
    mx)
      REGION_DISPLAY+="${or}${region}${nc}\n"
      ;;
    me)
      REGION_DISPLAY+="${mg}${region}${nc}\n"
      ;;
    sa)
      REGION_DISPLAY+="${gy}${region}${nc}\n"
      ;;
    *)
      REGION_DISPLAY+="${wh}${region}${nc}\n"
      ;;
    esac
  done <<<"$REGIONS"

  # Remove trailing newline from REGION_DISPLAY
  REGION_DISPLAY=${REGION_DISPLAY%\\n}

  # Let user select region via fzf
  SELECTED_REGION=$(echo -e "$REGION_DISPLAY" | fzf --ansi --height=50% --header="Select a region to switch to:")
  if [[ -z $SELECTED_REGION ]]; then
    exit 0
  fi

  # Remove color codes from selection
  SELECTED_REGION=$(echo "$SELECTED_REGION" | sed -E "s/\x1B\[[0-9;]*[mK]//g")

  # Update the default profile's region in AWS config
  awk -v new_region="$SELECTED_REGION" '
    BEGIN { in_default = 0 }
    /^\[default\]/ { in_default = 1; print; next }
    /^\[/ { in_default = 0; print; next }
    in_default && /^region =/ { print "region = " new_region; next }
    { print }
  ' "$AWS_CONFIG_FILE" >"$CTX_CONFIG"

  mv "$CTX_CONFIG" "$AWS_CONFIG_FILE"
  msg "success" "Updated default profile region to: $SELECTED_REGION" "üåç"
}

while getopts ":b:cghikmvo:r" opt; do
  case $opt in
  b) BROWSER_OVERRIDE="$OPTARG" ;;
  c)
    check_for_updates
    exit 0
    ;;
  g)
    GENERATE_CONFIG="true"
    if [[ -z $OUTPUT_FORMAT ]]; then
      validate_output
    fi
    ;;
  h)
    usage
    exit 0
    ;;
  i) setup_aws_config ;;
  k)
    check_command "kubectl" "https://kubernetes.io/docs/tasks/tools/"
    echo -n "${bl}Detecting EKS clusters...${nc}"
    detect_eks_clusters
    echo "${bl}Detecting EKS clusters...${gr}‚úì${nc}"
    exit 0
    ;;
  m)
    CURRENT_PROFILE=$(grep -b2 "$(aws configure get profile.default.sso_account_id)" ~/.aws/config | grep 'profile' | cut -d' ' -f2 | cut -d']' -f1)
    echo "${mg}Generating AWS Region Heatmap for $CURRENT_PROFILE...${nc}"
    regions=$(aws ec2 describe-regions --query "Regions[].RegionName" --output text)
    calculate_region_counts || {
      error "Failed to calculate region counts" "‚ùå"
      exit 1
    }
    print_heatmap || {
      error "Failed to print heatmap" "‚ùå"
      exit 1
    }
    exit 0
    ;;
  o) OUTPUT_FORMAT="$OPTARG" ;;
  r)
    change_region
    exit 0
    ;;
  v)
    DEBUG=true
    set -x
    ;;
  \?)
    echo "${rd}Invalid option: -$OPTARG üëÆüèª‚Äç‚ôÇÔ∏è${nc}"
    usage
    exit 1
    ;;
  :)
    echo "${rd}Option -$OPTARG requires an argument üòë${nc}"
    usage
    exit 1
    ;;
  esac
done

validate_token

if [[ $GENERATE_CONFIG == "true" ]]; then
  generate_config
  exit 0
fi

CONTEXT_READY="true"

change_context() {
  trap 'exit 2' SIGINT

  # Declare associative arrays with -A flag
  declare -A account_roles=()
  declare -A account_ids=()

  # First, build a map of accounts to their roles and IDs
  while read -r profile; do
    # Get the role and account name directly from the config file instead of parsing the profile name
    account_id=$(grep -A 3 "\[profile $profile\]" "$AWS_CONFIG_FILE" | grep 'sso_account_id' | awk -F' = ' '{print $2}')
    role_name=$(grep -A 3 "\[profile $profile\]" "$AWS_CONFIG_FILE" | grep 'sso_role_name' | awk -F' = ' '{print $2}')
    account_name=$profile
    account_name=${account_name#*@} # Remove everything before @ if it exists

    # Store the account ID
    account_ids[$account_name]=$account_id

    # Append role to the account's roles list
    if [[ -z ${account_roles[$account_name]+x} ]]; then
      account_roles[$account_name]="$role_name"
    else
      account_roles[$account_name]="${account_roles[$account_name]}, $role_name"
    fi
  done < <(awk -F '[][]' '/^\[profile / {print $2}' "$AWS_CONFIG_FILE" | sed 's/^profile //')

  # Get sorted account names
  readarray -t sorted_accounts < <(printf '%s\n' "${!account_roles[@]}" | sort)

  # Create the display string with colors for fzf, sorted alphabetically
  ACCOUNT_DISPLAY=""
  for account_name in "${sorted_accounts[@]}"; do
    ACCOUNT_DISPLAY+="${wh}${account_name}${nc} (${mg}${account_ids[$account_name]}${nc}) [${bl}${account_roles[$account_name]}${nc}]\n"
  done
  # Remove trailing newline
  ACCOUNT_DISPLAY=${ACCOUNT_DISPLAY%\\n}

  # First selection: Choose the account
  SELECTED_ACCOUNT=$(echo -e "$ACCOUNT_DISPLAY" | fzf --ansi --height=50% --header='Select an AWS account. Type to filter by name, ID, or roles:')
  if [[ -z $SELECTED_ACCOUNT ]]; then
    exit 0
  fi

  # Extract the account name from the selection (remove colors and extra info)
  ACCOUNT_NAME=$(echo "$SELECTED_ACCOUNT" | sed -E "s/\x1B\[[0-9;]*[mK]//g" | awk -F' \\(' '{print $1}')

  # Get roles for the selected account
  IFS=', ' read -r -a ROLES <<<"${account_roles[$ACCOUNT_NAME]}"

  # If there's only one role, use it directly
  if [[ ${#ROLES[@]} -eq 1 ]]; then
    SELECTED_ROLE="${ROLES[0]}"
  else
    # Sort roles alphabetically
    readarray -t ROLES < <(printf '%s\n' "${ROLES[@]}" | sort)
    
    # Second selection: Choose the role
    ROLE_DISPLAY=""
    for role in "${ROLES[@]}"; do
      ROLE_DISPLAY+="${bl}${role}${nc}\n"
    done
    # Remove trailing newline
    ROLE_DISPLAY=${ROLE_DISPLAY%\\n}

    SELECTED_ROLE=$(echo -e "$ROLE_DISPLAY" | fzf --ansi --height=50% --header="Select a role for ${wh}${ACCOUNT_NAME}${nc}:")
    if [[ -z $SELECTED_ROLE ]]; then
      exit 0
    fi
    # Remove color codes from selection
    SELECTED_ROLE=$(echo "$SELECTED_ROLE" | sed -E "s/\x1B\[[0-9;]*[mK]//g")
  fi

  # Construct the profile name
  PROFILE_NAME="${SELECTED_ROLE}@${ACCOUNT_NAME}"

  # Create a temporary file for the new config
  echo -n >"$CTX_CONFIG"

  # Write all non-default sections and the session block, ensuring exactly one newline at the end
  awk '
    BEGIN { in_default = 0; print_line = 1; last_empty = 0 }
    /^\[sso-session/ { in_default = 0; print_line = 1 }
    /^\[default\]/ { in_default = 1; print_line = 0; next }
    /^\[/ && !/^\[sso-session/ { in_default = 0; print_line = 1 }
    print_line {
      if (NF == 0) {
        if (!last_empty) print
        last_empty = 1
      } else {
        print
        last_empty = 0
      }
    }
    END { if (!last_empty) print "" }
  ' "$AWS_CONFIG_FILE" >"$CTX_CONFIG"

  # Get the new default section content first
  DEFAULT_CONTENT=$(awk -v profile="profile $PROFILE_NAME" '
    BEGIN { found = 0 }
    # Match either the exact profile name or just the account name for single-role accounts
    $0 ~ "^\\[" profile "\\]" || $0 ~ "^\\[profile " profile "\\]" { found = 1; next }
    /^\[/ && found { exit }
    found && NF { print }
  ' "$AWS_CONFIG_FILE")

  # If we didn't find content, try searching without the role prefix
  if [[ -z $DEFAULT_CONTENT ]]; then
    DEFAULT_CONTENT=$(awk -v account="$ACCOUNT_NAME" '
      BEGIN { found = 0 }
      $0 ~ "^\\[profile [^@]+@" account "\\]" { found = 1; next }
      /^\[/ && found { exit }
      found && NF { print }
    ' "$AWS_CONFIG_FILE")
  fi

  # Only add the default section if we got content
  if [[ -n $DEFAULT_CONTENT ]]; then
    echo "[default]" >>"$CTX_CONFIG"
    echo "$DEFAULT_CONTENT" >>"$CTX_CONFIG"
  else
    error "Failed to get profile content for $PROFILE_NAME" "‚ùå"
    exit 1
  fi

  # Replace the old config with the new one
  mv "$CTX_CONFIG" "$AWS_CONFIG_FILE"
  success "Switched default profile to: $PROFILE_NAME" "üîÄ"
  info "To change the region, run: awsctx -r"
}

if [[ $CONTEXT_READY == "true" ]]; then
  change_context
fi
